---
title: 애플리케이션 레이어
date: '2025-08-31'
order: '2'
---
*서버*는 항상 실행되고 있어야되고, 항상 동일한 IP주소를 가진다.
(같은 컴퓨터 안에서도 프로세스끼리 데이터를 주고 받을때 '소켓'이라는 인터페이스를 사용한다고 하는데, 멀리 떨어진 컴퓨터끼리 데이터를 전송하는것도 이것과 비슷하다고 한다.)

애플리케이션 레이어는, 트랜스포트 레이어 위에 있다. (그리고 네트워크 계층 맨 위에 있다.)
각 레이어들은 자기 위에 위치한 레이어들을 위해 어떤 기능들을 제공해준다고 한다.
트랜스포트 레이어는 애플리케이션 레이어에게 제공하는 서비스는 '*data integrity*' 가 있다. (TCP가 하고 UDP는 하지 않는다.)
애플리케이션이 필요로 하는 *timing*, *throughput*, *security* 는 트랜스포트 레이어에서 제공하지 않는다. 그래서 애플리케이션 계층에서 스스로 자급자족으로 해결.
> 타이밍 vs 스루풋 ?

# HTTP
Hyper Text Transfer Protocol

말 그대로 하이퍼 텍스트를 주고 받기 위한 프로토콜이다. (*하이퍼 텍스트* : 링크를 통해 다른 문서들과 연결되어 있는 문서.)
그래서 하이퍼 텍스트를 달라고하는 '요청'과 그에 맞는 하이퍼 텍스트를 보내주는 '응답' 두 종류의 메시지밖에 없다.

## stateless
HTTP는 *stateless* 하다. HTTP 구조가 너무 단순해서 요청하는 상대에 대해서 어떤 정보도 기억하고 있을 필요가 없다는 뜻.

## persistent / non-persistent HTTP
HTTP가 TCP를 사용하는 방식에 따라 persistent HTTP인지 non-persistent HTTP인지 나뉜다.

non-persistent HTTP는 TCP와 연결하고 **하나의** 파일을 전송한 후에 바로 연결을 닫는다. 
	1. HTTP클라이언트가 HTTP서버와 TCP연결을 시작.
	2. HTTP서버 연결을 수락하고 클라이언트에 알림.
	3. 클라이언트는 서버에 HTTP 요청 메시지를 TCP 연결 소켓에 전송.
	4. 요청을 받은 서버는 요청받은 파일을 담아 응답 메시지를 전송.
	5. **서버가 TCP 연결을 닫음.**
	6. 클라이언트는 응답을 받고 문서를 parsing하고 이 파일을 브라우저에 완전히 보여주기 위해서는 다른 파일들 (이미지 등)이 필요함을 감지.
	7. 1~5번 까지의 과정을 반복한다. (필요한 파일들의 수 만큼 반복.)

위의 과정은 번거로워 보인다, 특히나 현대 웹 환경에서는 html 파일 하나만으로 웹 페이지가 이루어지는 경우는 실질적으로 없으니 더욱 더 번거롭다. 그래서 사용하는게 persistent HTTP.

# 소켓
네트워크 통신도 결국 멀리 위치한 컴퓨터에 가동되고 있는 프로세스들끼리의 통신이다.
그래서 OS에서 제공하는 소켓 API(프로세스 끼리의 정보 교환을 가능하게 함)를 사용한다.

소켓의 종류는 어떤 전송 계층 프로토콜을 사용할지에 따라 두 가지로 나뉜다.
TCP 소켓과, UDP 소켓

## TCP 소켓
서버측에서 먼저 (함수는 C언어 기준)
	1. 소켓을 만든다 : `socket(int domain, int type, int protocol)`
	2. 소켓과 포트를 연결 : `bind(int sockfd, struct sockaddr* myaddr, int addrlen)`
	3. 해당 소켓이 요청을 받아들이는 용도임을 지정 : `listen(int sockfd, intbacklog)`
	4. 요청 받아들이기 시작 : `accept(int sockfd, struct sockaddr* cliaddr, int* addrlen)`

클라이언트 측에서는
	1. 클라이언트 측에서도 통신에 사용할 소켓을 만들어야 한다 : `socket()`
		- `bind()`는 필요하지 않다. 왜냐하면 클라이언트 쪽에서는 비어있는 포트 아무거나 사용해도 무방하기 때문에. 
	2. 만들어진 다른 소켓과 연결한다 : `connect(int sockfd, struct sockaddr* servaddr, int addrlen)`


